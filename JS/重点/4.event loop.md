# 浏览器事件循环
1. js是单线程语言,必须等到上一个任务执行完才能继续执行下一个,这样会造成阻塞,所以引入了异步任务.js里有一个执行栈
2. 整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”
3. 遇到同步任务,就直接放入执行栈里执行
4. 遇到异步任务,会再次分为宏任务和微任务分别放入不同队列
5. 当主线程内的任务执行完毕(主线程为空时)，会检查微任务的任务队列，如果有任务，就进入主线程全部执行，如果没有就从宏任务队列读取下一个宏任务执行
6. 每执行完一个宏任务就清空一次微任务队列，此过程会不断重复，这就是Event Loop

# nodejs事件循环

1. Timers
    Timers：用于存储定时器的回调函数(setlnterval,setTimeout)。
2. Pendingcallbacks
    Pendingcallbacks：执行与操作系统相关的回调函数，比如启动服务器端应用时监听端口操作的回调函数就在这里调用。
3. idle，prepare
    idle，prepare：系统内部使用。(这个我们程序员不用管)
4. Poll
    Poll：存储i/O操作的回调函数队列，比如文件读写操作的回调函数。
    在这个阶段需要特别注意，如果事件队列中有回调函数，则执行它们直到清空队列，否则事件循环将在此阶段停留一段时间以等待新的回调函数进入。但是对于这个等待并不是一定的，而是取决于以下两个条件：
    - 如果setlmmediate队列（check阶段）中存在要执行的调函数。这种情况就不会等待。
    - timers队列中存在要执行的回调函数，在这种情况下也不会等待。事件循环将移至check阶段，然后移至Closingcallbacks阶段，并最终从timers阶段进入下一次循环。
5. Check
    Check：存储setlmmediate的回调函数。
6. Closingcallbacks
    Closingcallbacks：执行与关闭事件相关的回调，例如关闭数据库连接的回调函数等。


# 总结
当主线程同步代码执行完毕后才会进入事件循环
事件循环总共分六个阶段，并且每个阶段都包括哪些回调需要记清楚。
事件循环中会先执行微任务再执行宏任务。
微任务会穿插在这六个阶段之间执行，每进入到下个阶段前会清空当前的微任务队列。
微任务中process.nextTick的优先级最高，会优先执行。
