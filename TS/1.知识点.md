# ts 面试题
## 1.typescript和javascript的区别
    typescript是javascript的超集，ts 添加了类型检查，类型检查可以提高代码的可读性，错误检查，代码提示。TS在保持 JavaScript 灵活性的同时，提供了更好的开发体验和代码质量保证，特别适合大型项目和团队协作。
    
## 2. never和void,unknown和any的区别
never 和 void 的区别：
- never 表示一个不会出现的值，比如抛出一个异常或者一个死循环。
- void 表示一个空值，即没有返回值或返回 undefined。
unknown 和 any 的区别：
- unknown 表示未知类型，是 any 类型的安全替代品。与 any 不同，对 unknown 类型的值进行操作前必须进行类型检查：
    ```typescript
    let value: unknown;
    if (typeof value === 'string') {
        console.log(value.toUpperCase());
    }
    console.log(value.toUpperCase()); // 编译错误
    ```
- any 表示任意类型，可以赋值给任意类型，会跳过 TypeScript 的类型检查。

## 3. interface(接口) 和 type(类型别名) 有什么区别？
    interface 和 type 都是定义数据类型的一种方式，但是它们有它们自己的用途和限制。
1: 定义的数据类型区别
- interface 是一种用于定义对象结构的类型，它可以被其他对象继承或实现。
- type 是一种用于定义别名的类型，它可以被其他类型引用。除了能够定义对象结构外，type还可以定义基本类型，联合类型等
```typescript
interface Person {
    name: string;
}
type Person = { name: string };
```
2: 扩展性
- interface可以重复声明并自动合并，type不可以
- interface通过extends关键字进行扩展，type使用交叉类型扩展
```typescript
interface I1 {
    name: string;
}
interface I2 extends I1 {
    age: number;
}
type T1 = {
    name: string;
}
type T2 = T1 & { age: number };
// 互相扩展
interface T3 extends T1 {
    employeeId: number;
}
type T3 = T1 & {
    employeeId: number;
};
```

## 4. 什么是联合类型和交叉类型
    联合类型：多个类型组成的类型，表示可以是多个类型中的一种
    交叉类型：多个类型组成的类型，表示同时满足多个类型

## 5. tyepscript 泛型和泛型约束
    泛型（Generics）：是解决代码复用、类型约束和类型推倒问题，在TypeScript 中，泛型允许创建一个函数，该函数可以接受任意类型作为参数，并返回任意类型。它允许我们在定义函数、接口或类时不预先指定具体的类型，而是在使用时再指定类型。
    泛型约束：允许我们对泛型参数进行限制，确保传入的类型满足特定条件。使用 extends 关键字来实现泛型约束。
1. 定义泛型函数
   ```typescript
   function identity<T>(arg: T): T {}
   function identity2<T extends {age:number}>(arg: T): T {}
   const result = identity<number>(123);
   const result2 = identity2<{age:number}>({age:10});
   ```
2. 创建泛型接口
    ```typescript
    interface GenericIdentityFn<T> { 
        (arg: T): T;
    }
    const identity: GenericIdentityFn<number> = function(arg) { return arg; };
    interface GenericIdentityFn2<T extends {age:number}> { 
        (arg: T): T;
    }
    const identity2: GenericIdentityFn2<{age:number}> = function(arg) { return arg; };
    ```
3. 创建泛型类
   ```typescript
    class GenericNumber<T> { 
        zeroValue: T;
        constructor(zero: T) {
            this.zeroValue = zero;
        }
    }
    let myGenericNumber = new GenericNumber<number>(0);
    class GenericNumber2<T extends {age:number}> {
        zeroValue: T;
        constructor(zero: T) {
            this.zeroValue = zero;
        }
    }
    let myGenericNumber2 = new GenericNumber2<{age:number}>({age:1});
   ```

## 6. 方法重载
    方法重载（Method Overloading）是一种允许函数在不同参数数量或参数类型下具有不同的返回类型或行为的特性。这允许您以一种更灵活的方式定义函数，并根据传入的参数类型或数量来选择适当的行为或返回类型。
要定义方法重载，您需要按照以下步骤进行：
1. 定义一个函数签名，该签名描述了函数的参数和返回类型。
2. 定义一个函数实现，该实现与函数签名匹配。
    ```typescript
        // 重载签名
        function processInput(input: string): string;
        function processInput(input: number): string;

        // 实现签名
        function processInput(input: string | number): string {
        if (typeof input === "string") {
            return input.toUpperCase();
        } else {
            return input.toFixed(2);
        }
        }
        // 使用
        const result1 = processInput("hello"); // 类型为 string
        const result2 = processInput(3.14159); // 类型为 string
    ```

## 7. 方法重写
    方法重写是指在子类中重新定义父类中已有的方法，以提供特定于子类的实现。这是面向对象编程中继承机制的重要特性。
方法重写的规则
1. 该方法必须具有与父类相同的名称
2. 该方法必须具有与父类相同的参数。
3. 必须有一个IS-A关系(继承)。
    ```typescript
    class Vehicle {
        protected speed: number = 0;
        // 公共方法
        public start(): void {
            console.log("Vehicle started");
        }
        // 受保护的方法
        protected accelerate(): void {
            this.speed += 10;
            console.log(`Speed: ${this.speed} km/h`);
        }
    }
    class Car extends Vehicle {
        // 重写公共方法
        override public start(): void {
            console.log("Car engine started");
            super.start();
        }
        // 重写受保护方法
        override protected accelerate(): void {
            this.speed += 20; // 汽车加速更快
            console.log(`Car speed: ${this.speed} km/h`);
        }
        public drive(): void {
            this.start();
            this.accelerate();
        }
    }

    const car = new Car();
    car.drive();
    // 输出:
    // Car engine started
    // Vehicle started
    // Car speed: 20 km/h
    ```

## 8. const和readonly的区别
    const 和 readonly 都是 TypeScript 中的关键字，用于定义变量。
    const 用于定义常量。一旦定义，常量的值就不能改变。
    readonly 用于标记类的属性，定义只读变量。一旦定义，只读变量的值就不能改变。

## 9. 什么是类型映射
    类型映射（Type Mapping）是一种用于定义类型转换的机制。它允许我们基于现有类型创建新类型。

## 10. 模块和命名空间
    模块是包含自己作用域的代码文件，模块内部的变量、函数、类等不会自动暴露到全局作用域。模块通过 export 和 import 关键字来共享代码。
    命名空间是组织代码的一种方式，用于逻辑分组相关的代码。使用 namespace 关键字定义，可以包含类、接口、函数、变量等。需要暴露的内容必须通过 export 关键字显式指定。
